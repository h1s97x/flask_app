## 概述

本项目使用到一些进阶的 Flask 开发技术包括特殊数据库关系、用户注册、权限管理、高级数据库查询、全文搜索和实时推送等 。
涉及的Python包如下所示：
□ Flask-Dropzone ( 1.5 )
文档：
https://flask-dropzone.readthedocs.io
□ Pillow ( 5.1.0 )
源码：
https://github.com/python-pillow/Pillow
文档：
https://pillow.readthedocs.io
□ Flask-Avatars ( 0.2 )
文档：
https://flask-avatars.readthedocs.io
□ Whoosh (2.7.4)
文档:
http://whoosh.readthedocs.org/
□ Flask-Whooshee ( 0.6.0 )
文档：
https://flask-whooshee.readthedocs.io

### 项目依赖包

```
blinker==1.4
bootstrap-flask==1.2.0
click==7.1.1
flask-avatars==0.2.2
flask-dropzone==1.5.4
flask-login==0.5.0
flask-mail==0.9.1
flask-moment==0.9.0
flask-sqlalchemy==2.4.1
flask-whooshee==0.7.0
flask-wtf==0.14.3
flask==1.1.2
itsdangerous==1.1.0
jinja2==2.11.1
markupsafe==1.1.1
pillow==9.5.0
python-dotenv==0.12.0
sqlalchemy==1.3.15
werkzeug==1.0.1
whoosh==2.7.4
wtforms==2.2.1
# dev
faker==4.0.2
pathtools==0.1.2
python-dateutil==2.8.1
six==1.14.0
text-unidecode==1.3
watchdog==0.10.2
```

#### python包的批量安装

```
pip install -r requirements.txt
```

#### python包的批量导出

```
pip freeze > requirements.txt
```

> 注意：这个CMD命令会导出系统环境下的所有python包，不仅限于项目的包。

## 项目组织架构

在大型 Flask 项目中，主要有三种常见的项目组织架构：功能式架构、分区式架构和混合式架构 。

### 功能式架构

在功能式架构中，程序包由各个代表程序组件（功能）的子包组成，比如 blueprints （蓝本）、forms （表单）、templates （模板）、models （模型）等，在这些子包中，按照程序的板块分模块来组织代码，比如 forms 子包下包含 front.py 、
auth.py 和 dashboard.py 。 这种架构结构清晰，更容易在开发时让开发者迅速找到文件，其他维护者也能迅速了解程序结构。 使用功能式架构的程序包目录结构示意如下：

```
myapp/
	blueprints/
		- __init__.py
		- auth.py
		- dashboard.py
		- front.py
	forms/
		- __init__.py
		- auth.py
		- dashboard.py
		- front.py
	static/
	templates/
		- auth/
		- dashboard/
		- front/
		- base.html
- __init__.py
```

因为程序比较简单，蓝本主要是用来组织路由，所以项目中的蓝本直接在 blueprints 包下的模块中创建 。 如果蓝本需要注册更多的处理程序，比如错误处理函数、请求处理函数等，可以在 blueprints 包中为 每个蓝本创建单独的子包，目录结构示意如下所示：

```
myapp/
	blueprints/
		- __init__.py
		auth/
			- __init__.py
			- views.py
			- errors.py
		/dashboard
			- __init__.py
			- views.py
			- errors.py
		/front
			- __init__.py
			- views.py
			- errors.py
```

通过为蓝本创建子包还可以支持为蓝本创建独立的 templates 和 static 文件夹：

```
myapp/
	blueprints/
		- __init__.py
		auth/
			- __init__.py
			- views.py
			- errors.py
			templates/
			static/
		dashboard/
			- __init__.py
			- views.py
			- errors.py
			templates/
			static/
		...
```

### 分区式架构

在分区式架构中，程序被按照自身的板块分成不同的子包 。myapp 使用分区式架构可以分别创建 front 、auth 和 dashboard 三 个子包，这些子包直接在程序包的根目录下创建，子包中使用模块组织不同的程序组件，比如 views . py 、forms .py 等。这种分类自然决定 了 每一个子包都对应着一个蓝本，这时蓝本在每个子包的构造文件中创建 。 使用分区式架构的程序包目录结构示意如下所示：

```
myapp/
	- __init__.py
	dashboard/
		- __init__.py
		- views.py
		- forms.py
		templates/
		static/
	auth/
		- __init__.py
		- views.py
		- forms.py
		templates/
		static/
	front/
		- __init__.py
		- views.py
		- forms.py
		templates/
		static/
```

### 混合式架构

混合式架构，顾名思义，就是不按照常规分类来组织 。比如，采用类似分区式架构的子包来组织程序，但各个蓝本共用程序包根目录下的模板文件夹和静态文件文件夹。

### 本项目采用的组织架构

为了让项目更加规范化，增加模块化设计以及让代码重用率更高，项目结构我采取了Flask的功能式架构。

项目程序包目录结构如下：

```
----blog\
    |----blueprints\
    |    |----admin.py
    |    |----ajax.py
    |    |----auth.py
    |    |----main.py
    |    |----user.py
    |    |----__init__.py
    |----forms\
    |    |----admin.py
    |    |----auth.py
    |    |----main.py
    |    |----user.py
    |    |----__init__.py
    |----templates\
    |    |----admin\
    |    |    |----edit_profile.html
    |    |    |----index.html
    |    |    |----manage_comment.html
    |    |    |----manage_photo.html
    |    |    |----manage_tag.html
    |    |    |----manage_user.html
    |    |----auth\
    |    |    |----login.html
    |    |    |----register.html
    |    |    |----reset_password.html
    |    |----base.html
    |    |----emails\
    |    |    |----change_email.html
    |    |    |----change_email.txt
    |    |    |----confirm.html
    |    |    |----confirm.txt
    |    |    |----reset_password.html
    |    |    |----reset_password.txt
    |    |----errors\
    |    |    |----400.html
    |    |    |----403.html
    |    |    |----404.html
    |    |    |----413.html
    |    |    |----500.html
    |    |----macros.html
    |    |----main\
    |    |    |----collectors.html
    |    |    |----explore.html
    |    |    |----index.html
    |    |    |----notifications.html
    |    |    |----photo.html
    |    |    |----profile_popup.html
    |    |    |----search.html
    |    |    |----tag.html
    |    |    |----upload.html
    |    |    |----_comment.html
    |    |    |----_photo_sidebar.html
    |    |    |----_sidebar.html
    |    |----user\
    |    |    |----collections.html
    |    |    |----followers.html
    |    |    |----following.html
    |    |    |----index.html
    |    |    |----settings\
    |    |    |    |----base.html
    |    |    |    |----change_avatar.html
    |    |    |    |----change_email.html
    |    |    |    |----change_password.html
    |    |    |    |----delete_account.html
    |    |    |    |----edit_notification.html
    |    |    |    |----edit_privacy.html
    |    |    |    |----edit_profile.html
    |    |    |----_header.html
    |----static\
    |    |----css\
    |    |    |----black_swan.min.css
    |    |    |----bootstrap-grid.css
    |    |    |----bootstrap-grid.css.map
    |    |    |----bootstrap-grid.min.css
    |    |    |----bootstrap-grid.min.css.map
    |    |    |----bootstrap-reboot.css
    |    |    |----bootstrap-reboot.css.map
    |    |    |----bootstrap-reboot.min.css
    |    |    |----bootstrap-reboot.min.css.map
    |    |    |----bootstrap.css
    |    |    |----bootstrap.css.map
    |    |    |----bootstrap.min.css
    |    |    |----bootstrap.min.css.map
    |    |    |----dropzone.min.css
    |    |    |----perfect_blue.min.css
    |    |    |----style.css
    |    |----favicon.ico
    |    |----images\
    |    |    |----error.jpg
    |    |    |----index.jpg
    |    |----js\
    |    |    |----bootstrap.bundle.js
    |    |    |----bootstrap.bundle.js.map
    |    |    |----bootstrap.bundle.min.js
    |    |    |----bootstrap.bundle.min.js.map
    |    |    |----bootstrap.js
    |    |    |----bootstrap.js.map
    |    |    |----bootstrap.min.js
    |    |    |----bootstrap.min.js.map
    |    |    |----dropzone.min.js
    |    |    |----jquery.min.js
    |    |    |----moment-with-locales.min.js
    |    |    |----popper.min.js
    |    |    |----script.js
    |----decorators.py
    |----emails.py
    |----extensions.py
    |----fakes.py
    |----models.py
    |----notifications.py
    |----settings.py
    |----utils.py
    |----__init__.py

```

## 程序骨架

![](blog/image/程序骨架.png)

程序主要包含四个部分：认证系统 、主要功能 、 用户系统、 管理系统 。 我们在 blueprints 包 中创建了五个模块，除了表示上面四部分的 auth （认证 ）、main （主要功能）、user （用户）和 admin （管理）外，为了便于组织处理 AJAX 请求的视图函数，还创建了一个 ajax 模块 。

```
----blog\
	|----blueprints\
    |    |----admin.py
    |    |----ajax.py
    |    |----auth.py
    |    |----main.py
    |    |----user.py
    |    |----__init__.py
    |----forms\
    |    |----admin.py
    |    |----auth.py
    |    |----main.py
    |    |----user.py
    |    |----__init__.py
    |----templates\
    |    |----admin\
    |    |----auth\
    |    |----main\
    |    |----user\
    |    |----base.html
    |    |----macros.html
-__init__.py
- decorators.py 装饰器
- extensions.py 扩展
- fakes.py 虚拟数据
- models.py 数据库
- notisfications.py 提醒消息
- settings.py 全局设置
- utils.py 辅助函数
- emails.py 电子邮件
```

在程序包的根目录中，

utils.py 用来存储各种辅助函数（即 utilities 的 简写），比如重定向回上一个页面的 redirect_back()以及验证 URL 安全性的url_safe( ） 。

fakes.py 脚本存储虚拟数据生成函数 。比如，为了模拟一个虚拟博客，需要创建虚拟的博客信息、文章、分类和评论。使用函数生成大量不同种类的虚拟数据，更易于重用 。

emails.py 用来存储发送电子邮件的函数。为了更方便使用，除了通用的发信函数，我们还会创建特定的发信函数。比如，用户发送新评论提醒的函数

extensions.py 用来存储扩展实例化等操作

decorators. py 脚本用来存储装饰器

notifications.py 脚本则存储发送消息提醒的函数 。

在工厂函数里，为程序加载配置并注册各种处理函数。除了注册蓝本、扩展和错误处理函数，还为程序添加了自定义命令、shell上下文处理器、模板上下文处理器以及错误处理器。

### 数据库模型与虚拟数据

Blog中共用到 9 个数据库模型，分别为用户、角色、权限、博客、标签、评论 、收藏、关注和消息 。 用户模型作为关系的中心，其他数据模型大多和它建立一对多关系，

**什么是** **Faker** **模块？**

Faker 是 Python 中的一个模块，用于生成逼真的假数据。它可以用于模拟测试数据，填充数据库，生成虚拟用户个人信息等。Faker 支持许多不同的数据类型，例如名称、地址、日期时间、通讯信息、公司信息、用户信息等。

**为什么使用** **Faker** **模块？**

在软件开发过程中，通常需要在测试阶段使用测试数据。手动创建测试数据是一项繁琐而耗时的工作。为了简化这个流程，Faker 模块被设计和开发出来。同时，填充数据的情况也可以出现在数据科学、机器学习或其他领域的构建和分析过程中。

fakes.py 脚本包含对应主要数据库模型类的虚拟数据生成函数，在构造文件中创建的 forge(）命令 函数集合了这些虚拟数据生成函数 。 这些函数用来生成几乎所有类别的数据：用户、关注、标签、图片、博文、评论 、收藏。

虽然Faker的功能已经很强大了，但是也有一些缺陷，比如无法生成真实的图片。

所以第一版的程序这里使用图片库和Pillow生成随机颜色的图片 ：

我们会用到一个流行的图像处理库－Pillow ：Pillow 是PIL (Python Image Library, Python 图片处理库）的派生(fork) ，它在 PIL 的基础上增加了对Python3.x 的支持和其他的改进 。
```
import random
from PIL import Image
filename = 'random_%d.jpg' % i
r = lambda: random.randint(128, 255)
img = Image.new(mode='RGB', size=(800, 800), color=(r(), r(), r()))
img.save(filename)
```

首先从 PIL 包 导入 Image 类 ，调用 new()创建一个图片对象，使用 mode 参数将图片模式设置为 RGB,size 参数传入表示图片宽高尺寸的元组，color 参数设置包含 RGB 值的三元素元组。这里的色彩数值 (0~255 区间的整数）通过 random.randint(）函数生成，将取值限定在 128~255 区间，以获取明亮的色彩值 。最后对图片对象调用 save(）方法保存，传入图片保存路径 。



## 用户认证

在大型的社交程序中，用户认证的基础是账号注册。需要提供账户注册功能以便让用户自已完成用户信息的录入 。通常包含一些基本步骤，比如填 写 注册信息、接收验证邮件、通过单击验证链接来确认账号等。

模型类 User 用于存储用户信息:（model.py)

```
class User(db.Model, UserMixin):
    id = db.Column(db.Integer, primary_key=True)
    # 用户资料
    username = db.Column(db.String(20), unique=True, index=True)
    email = db.Column(db.String(254), unique=True, index=True)
    password_hash = db.Column(db.String(128))
    name = db.Column(db.String(30))
    website = db.Column(db.String(255))
    bio = db.Column(db.String(120))
    location = db.Column(db.String(50))
    member_since = db.Column(db.DateTime, default=datetime.utcnow)
    # 用户状态
    confirmed = db.Column(db.Boolean, default=False)
    locked = db.Column(db.Boolean, default=False)
    active = db.Column(db.Boolean, default=True)

```

> 注：这里并没有给出完整的User类定义。

User 类继承自Flask-Login 提供的 UserMixin 类。
除了几个存储用户资料的字段外，比较关键的是用来存储账户确认状态的 confirmed 字段。
confirmed 字段使用 default 参数将默认值设为False。另外，username 和 email 字段通过设置 unique 参数为True,确保不会产生重复值 ；将 index 参数设为 True 来为这两个字段建立索引，这会提高使用这两个字段查询用户对象的效率 。

### 用户注册

用户注册需要填写表单。下面是用于注册的表单类。

forms/auth.py

```
from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField, BooleanField
from wtforms import ValidationError
from wtforms.validators import DataRequired, Length, Email, EqualTo, Regexp

class RegisterForm(FlaskForm):
    name = StringField('Name', validators=[DataRequired(), Length(1, 30)])
    email = StringField('Email', validators=[DataRequired(), Length(1, 254), Email()])
    username = StringField('Username', validators=[DataRequired(), Length(1, 20),
                                                   Regexp('^[a-zA-Z0-9]*$',
                                                          message='The username should contain only a-z, A-Z and 0-9.')])
    password = PasswordField('Password', validators=[
        DataRequired(), Length(8, 128), EqualTo('password2')])
    password2 = PasswordField('Confirm password', validators=[DataRequired()])
    submit = SubmitField()

    def validate_email(self, field):
        if User.query.filter_by(email=field.data.lower()).first():
            raise ValidationError('The email is already in use.')

    def validate_username(self, field):
        if User.query.filter_by(username=field.data).first():
            raise ValidationError('The username is already in use.')

```

用户的账户名( username) 是用户在网站中的重要标识，用户的个人主页 URL 将基于这个值构建，因此这个值不能重复，而且应该由英文字母、数字和少数符号组成。为了达到这个目的，在 username 字段中使用了Regexp 验证器，利用正则表达式来验证输入值 。

为了防止用户输错密码，表单中有两个密码字段：password 、password2 。 通过 EqualTo 验证器来确保其输入值与 password2 字段的输入值相同。

为了避免用户输入过于简单的密码，将密码长度的最小限制设置为 8 。

除了进行长度限制外，要确保 User 模型中的 username 和 email 字段的不会与已有的数据重复，所以添加了两个自定义验证方法——validate_username(）和 validate_email(），分别用于验证表单的 username 和 email 字段。这两个验证函数会验证数据库中是否存在包含相同字段值的记录。如果包含，就抛出 ValidationError 异常，错误信息作为参数传入。

处理注册请求：

blueprint/auth.py

```
from blog.emails import send_confirm_email
from blog.forms.auth import RegisterForm

@auth_bp.route('/register', methods=['GET', 'POST'])
def register():
    if current_user.is_authenticated:
        return redirect(url_for('main.index'))

    form = RegisterForm()
    if form.validate_on_submit():
        name = form.name.data
        email = form.email.data.lower()
        username = form.username.data
        password = form.password.data
        user = User(name=name, email=email, username=username)
        user.set_password(password)
        db.session.add(user)
        db.session.commit()
        token = generate_token(user=user, operation='confirm')
        send_confirm_email(user=user, token=token)
        flash('Confirm email sent, check your inbox.', 'info')
        return redirect(url_for('.login'))
    return render_template('auth/register.html', form=form)

```

先判断表单提交状态，如果用户没有提交表单，就渲染注册页面模板(auth/register.html) 。 反之则对表单数据进行验证，当数据通过验证后，就实例化User 类，创建一条数据库记录。 

在提交数据库会话后，还进行了一些其他工作:

```
token = generate_token(user=user, operation='confirm')
send_confirm_email(user=user, token=token)
flash('Confirm email sent, check your inbox.', 'info')
```

这些代码会生成一个验证令牌( token ) ，然后向用户的邮箱发送一封验证邮件，最后显示一条消息。

### 验证邮箱地址

大家都应该已经注册过很多的社交网站账号，那么应该对整个验证过程相当熟悉 ：

当你填写完注册信息后，网站会发送一封验证邮件到你的邮箱 。 这封邮件里包含一个很长的验证链接（或是一个指向这个长链接的按钮）：



![](blog/image/验证邮箱.png)

当你访问这个链接后 ，网站就会告诉你验证成功了 ，这就是令牌token的作用。

令牌中包含了要被确认的用户信息，在接收到这类请求后 ，网站会解析令牌以获得存储在其中的用户id, 然后执行确认操作。因为令牌经过签名，所以可以确保其不会被篡改，这样可以避免用户对其他账户进行确认操作。本项目采用的令牌是 JWS ( JSON Web Signature）。

生成确认令牌：

blog/utils.py

```
from itsdangerous import TimedJSONWebSignatureSerializer as Serializer
def generate_token(user, operation, expire_in=None, **kwargs):
    s = Serializer(current_app.config['SECRET_KEY'], expire_in)

    data = {'id': user.id, 'operation': operation}
    data.update(**kwargs)
    return s.dumps(data)

```

在这个函数 中 ，我们首先实例化 itsdangerous 包 提供的 TimedJSONWebSignatureSerializer类（简 记为 Serializer ) ，获得一个序列化对象 。 这个类的构造方法接收一个密钥作为参数，用来生成签名，这里使用配置变量 SECRET_KEY 的 值 。 可选的 expire_in 参数用来设置过期时间，默认为 3600（单位为秒，即一小时）。

发送确认邮件：

使用 Flask-Mail 实现发信功能。创建了 HTML 和纯文本两种格式的邮件正文 。邮件正文存储在单独的模板文件( HTML 文件和纯文本文件）中 ，这些模板存放在templates 目录下的 emails 文件夹中 。

邮件正文：

```
<p>Hello {{ user.username }},</p>
<p>Welcome to <b>Blog</b>!</p>
<p>Please visit the link below to verify your email address:<br>
    <a href="{{ url_for('auth.confirm', token=token, _external=True) }}">{{ url_for('auth.confirm', token=token, _external=True) }}</a>
</p>
<small>(Please do not reply to this notification, this inbox is not monitored.)</small>
```

 在 emails 模块中，创建了通用发信函数 send_mail()和用于发送验证邮件的 send_confirm_email()函数：

```
from threading import Thread
def send_mail(to, subject, template, **kwargs):
    message = Message(current_app.config['BLOG_MAIL_SUBJECT_PREFIX'] + subject, recipients=[to])
    message.body = render_template(template + '.txt', **kwargs)
    message.html = render_template(template + '.html', **kwargs)
    app = current_app._get_current_object()
    thr = Thread(target=_send_async_mail, args=[app, message])
    thr.start()
    return thr
    
def send_confirm_email(user, token, to=None):
    send_mail(subject='Email Confirm', to=to or user.email, template='emails/confirm', user=user, token=token)

```

使用通用发信函数中的 render_template()函数把这些关键字参数传入模板中，Jinja2 会像往常一样把它们渲染出来，其中验证链接通过下面的 url_for()函数调用生成：

```
{{ url_for('auth.confirm', token=token, _external=True) }}
```

验证并解析确认令牌：

blog/utils.py

```
from flask import current_app
from itsdangerous import BadSignature, SignatureExpired
from itsdangerous import TimedJSONWebSignatureSerializer as Serializer

def validate_token(user, token, operation, new_password=None):
    s = Serializer(current_app.config['SECRET_KEY'])

    try:
        data = s.loads(token)
    except (SignatureExpired, BadSignature):
        return False

    if operation != data.get('operation') or user.id != data.get('id'):
        return False

    if operation == Operations.CONFIRM:
        user.confirmed = True
    elif operation == Operations.RESET_PASSWORD:
        user.set_password(new_password)
    elif operation == Operations.CHANGE_EMAIL:
        new_email = data.get('new_email')
        if new_email is None:
            return False
        if User.query.filter_by(email=new_email).first() is not None:
            return False
        user.email = new_email
    else:
        return False

    db.session.commit()
    return True
```

首先使用和创建令牌时相同的密钥创建一个序列化对象，它提供一个 loads()函数，接收令牌值作为参数，返回从负载(Payload) 中提取出的数据 。 如果提取失败，通常会抛出SignatureExpired 异常或 BadSignature 异常，这两个异常分别表示签名过期和签名不匹配，在这种情况下将会返回 False 。如果数据提取成功，会验证数据中存储的 operation 值是否和传入的 operation 参数匹配，这会确保执行正确的操作；另外，还会验证数据中的用户 id 值与当前用户的 id 是否相同，这样即使恶意用户获取到了令牌值也无法确认其他用户的账户 。

当上面的一系列验证都通过时，我们将用户对象的 confirmed 属性设为 True 并提交数据库会话 。 最后返回 True , 表明令牌通过了验证。

处理验证请求：

blueprints/auth.py:

```
@auth_bp.route('/confirm/<token>')
@login_required
def confirm(token):
    if current_user.confirmed:
        return redirect(url_for('main.index'))

    if validate_token(user=current_user, token=token, operation=Operations.CONFIRM):
        flash('Account confirmed.', 'success')
        return redirect(url_for('main.index'))
    else:
        flash('Invalid or expired token.', 'danger')
        return redirect(url_for('.resend_confirm_email'))
```

首先判断当前用户的确认状态，当已经确认过的用户单击验证链接时，程序会把用户重定向到主页 。

然后使用 validate_token() 函数对通过 URL 变量传入的 token 进行验证，除了 token 变量，我们还传入 current_user 变址作为 user 参数以及对应的操作字符串 。 如果 validate_token()返回True , 说明验证通过，用户的确认字段值也已经更新，我们就把程序重定向到首页，并显示一个成功的提示 。 验证未通过时，就闪现一条错误提示消息，并将程序重定向到用于重新发送验证邮件的 resend_confirm_email 视图:

blueprints/auth.py:

```
@auth_bp.route('/resend-confirm-email')
@login_required
def resend_confirm_email():
    if current_user.confirmed:
        return redirect(url_for('main.index'))

    token = generate_token(user=current_user, operation=Operations.CONFIRM)
    send_confirm_email(user=current_user, token=token)
    flash('New email sent, check your inbox.', 'info')
    return redirect(url_for('main.index'))
```

在这个视图函数中，我们先判断用户的确认状态，已确认的用户会被重定向到首页。如果用户未确认，则重新生成令牌，并发送验证邮件和消息提醒 ，最后重定向到程序首页 。

### 使用装饰器过滤未确认用户
对于没有验证邮箱的用户，通常会采取一些方法来促使用户去验证 。比如，禁止用户登录；或允许登录，但显示一个提醒确认页面 。 更温和友好的做法是允许用户登录，但对于一些关键的功能，只对验证过邮箱地址的用户开放 。

Flask - Login 提供的 login_required 装饰器可以禁止未登录的用户访问视图 。我们也可以实现一个类似的装饰器，来禁止未确认用户访问某些关键视图。我们在程序包的根目录下创建的 decorators.py 脚本用于存储装饰器函数，实现用于过滤未确认用户的 confirm _required 装饰器的代码 。

decorators.py

```
from functools import wraps
def confirm_required(func):
    @wraps(func)
    def decorated_function(*args, **kwargs):
        if not current_user.confirmed:
            message = Markup(
                'Please confirm your account first.'
                'Not receive the email?'
                '<a class="alert-link" href="%s">Resend Confirm Email</a>' %
                url_for('auth.resend_confirm_email'))
            flash(message, 'warning')
            return redirect(url_for('main.index'))
        return func(*args, **kwargs)
    return decorated_function

```

通过用户对象的 confirmed 属性判断用户的确认状态，如果当前用户已经确认，则跳过代码，执行视图函数内容。如果用户未确认，则向用户闪现一条提示消息 ，并将程序重定向到主页 。

由于种种原因，比如发信服务器出错或用户误删除，有时用户可能会需要重新发送验证邮件。因此，我们在闪现的 flash 消息中添加一个指向 auth. resend_ confirmation 视图的链接，用来重新发送验证邮件 。通过 flash () 函数发送的消息在模板中渲染，消息内容会被自动转义为普通文本。为了让消息中的 HTML代码被正确渲染 ，可以利用前面介绍过的 safe 过滤器来避免 Jinja2 对变量转义，但对 flash 消息使用 safe 过滤器会造成安全隐患，因为攻击者可能会篡改消息内 容。 更安全
的做法是将传入 flash ()函 数 的文本转换 为 Markup 对象 。Flask 提供 的 Markup 类 可以将文本标记为安全文本 ，从而避免在渲染时对 Jinja2 进行转义 。

现在，我们可以在需要确认后才允许访问的视图函数前附加 confirm—required ，比如 upload视图：

```
@main_bp.route('/upload', methods=['GET', 'POST'])
@login_required
@confirm_required
def upload():
	...
```

多个装饰器的调用顺序可以简单理解为由外向内，当然 ，实际的调用要复杂得多 。当upload 函数被调用时，route() 装饰器会先被调用；接着，开始执行login_required () 函数中的代码，判断用户是否登录 ，未登录用户会被重定向到登录页面 ；然后是 confirm_required()函数 ，这时未验证的用户都会被过滤掉 ，重定向到首页；一系列装饰器都执行完毕后，才会执行视图函数本身的代码 。

### 密码重置

用户忘记密码是很常见的事情，这一节会介绍程序的密码重置功能 。 
当表单通过验证后，我们首先通过表单数据中的 Email 地址查询对应的用户 。如果用户存在就验证密码 ，否则发送提示消息“无效的用户名或密码” 并重定向回登录页面：

```
@auth_bp.route('/login', methods=['GET', 'POST'])
def login():
	...
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data.lower()).first()
        if user is not None and user.validate_password(form.password.data):
			...
        flash('Invalid email or password.', 'warning')
    return render_template('auth/login.html', form=form)
```

在 login.html 模板中，登录表单的下面添加两个链接，分别指向注册页面和密码找回页面 ：

```
<p class="small"><a href="{{ url_for('.register') }}">Register new account</a></p>
<p class="small"><a href="{{ url_for('.forget_password') }}">Forget password</a></p>
```

forget_password 视图:

blueprints/auth.py

```
@auth_bp.route('/forget-password', methods=['GET', 'POST'])
def forget_password():
    if current_user.is_authenticated:
        return redirect(url_for('main.index'))

    form = ForgetPasswordForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data.lower()).first()
        if user:
            token = generate_token(user=user, operation=Operations.RESET_PASSWORD)
            send_reset_password_email(user=user, token=token)
            flash('Password reset email sent, check your inbox.', 'info')
            return redirect(url_for('.login'))
        flash('Invalid email.', 'warning')
        return redirect(url_for('.forget_password'))
    return render_template('auth/reset_password.html', form=form)
```

当用户单击这个链接时，我们向用户提供一个重置表单，表单仅包含一个文本字段用于输入 Email。表单提交后，我们获取用户输入的邮箱地址，并根据邮箱地址查询对应的用户记录，如果没有找到相应的用户，就向用户显示一条错误消息。如果找到了就像确认邮箱一样使用 generate_token()函数 创 建一个令牌，传入 operation 的值为表示密码重置操作的 `Operations.RESET_PASSWORD` 变 量，最后使用 send_reset_password_ email() 函数向用户的邮箱发送验证邮件，以便确认是用户 本人发起的密码重置操作 。

验证令牌并重置密码的操作由 reset_password 视图处理:

blueprints/auth.py

```
@auth_bp.route('/reset-password/<token>', methods=['GET', 'POST'])
def reset_password(token):
    if current_user.is_authenticated:
        return redirect(url_for('main.index'))

    form = ResetPasswordForm()
    if form.validate_on_submit():
        user = User.query.filter_by(email=form.email.data.lower()).first()
        if user is None:
            return redirect(url_for('main.index'))
        if validate_token(user=user, token=token, operation=Operations.RESET_PASSWORD,
                          new_password=form.password.data):
            flash('Password updated.', 'success')
            return redirect(url_for('.login'))
        else:
            flash('Invalid or expired link.', 'danger')
            return redirect(url_for('.forget_password'))
    return render_template('auth/reset_password.html', form=form)

```

为了支持在解析令牌后设置新密码，在validate_token(）函数中添加 new_password 参数来传入表单中的密码字段值，并为令牌中id 对应的用户更新密码 ：

```
def validate_token(user, token, operation, new_password=None):
	...
    if operation == Operations.CONFIRM:
        user.confirmed = True
    elif operation == Operations.RESET_PASSWORD:
        user.set_password(new_password)
    else:
        return False
    db.session.commit()
    return True

```

## 基于角色的权限控制

在简单的程序中，通常只有两种用户角色，比如个人博客只有博客作者和匿名的访客。这时并不需要在区分角色和管理权限上花太多功夫，仅仅使用 Flask-Login 提供的 is_authenticated 属性就可以判断角色：登录的是管理员(is_authenticated 为 True) ，未登录的就是访客(is_authenticated 为 False)。为视图函数附加 login_required 装饰器就可以确保只有登录的用户才可以访问对应的资源 。

在更复杂一些的程序中，在登录的用户中还需要进一步区分出普通用户和管理员 。 这时可以像过滤未确认用户一样，在 User 模型中添加一个 admin 字段和一个相应的 admin_required 装饰器，来保护只对管理员开放的资源 。通常大型程序需要更多的用户角色： 拥有最高权限的管理员 、 负责管理内容的协管员 、 使用网站提供的服务的普通用户、因为违规操作而被临时封禁的用户等 。 每类用户所能进行的操作权限自然不能完全相同，我们需要根据用户的角色赋予不同的权限 。

比如，普通用户可以上传图片、发表评论，但被临时封禁的用户只能删除和编辑已经上传的图片或删除巳经发表的评论；协管员除了具有普通用户的所有权限，还可以删除或屏蔽不当评论、图片以及违规的用户；管理员的权限最大，除了拥有其他角色的权限外，还可以更改用户的角色、管理网站信息、发布系统消息等 。

在计算机安全领域，这种管理方法被称为 RBAC (Role-Based Access Control,基于角色的权限控制）我们将在这一节使用这个方法实现权限管理功能 。

### 角色与权限模型

models.py:

```
class Permission(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(30), unique=True)

class Role(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(30), unique=True)
    users = db.relationship('User', back_populates='role')
    
```

在表示角色的 Role 类中，name 字段存储角色的名称。类似的，在表示权限的 Permission类中，name 字段用来存储权限的名称 。

每个角色可以拥有多种权限，而每个权限又会被多个角色拥有。角色和权限之间通过关联表 roles_permissions 建立多对多关系：

```
# relationship table
roles_permissions = db.Table('roles_permissions',
                             db.Column('role_id', db.Integer, db.ForeignKey('role.id')),
                             db.Column('permission_id', db.Integer, db.ForeignKey('permission.id'))
                             )
class Role(db.Model):
	...
    permissions = db.relationship('Permission', secondary=roles_permissions, back_populates='roles')
class Permission(db.Model):
	...
    roles = db.relationship('Role', secondary=roles_permissions, back_populates='permissions')
```

另外，每个角 色都会有多个用户，Role 模型和 User 模 型 之间建立 了 一对多的关系:

```
class Role(db.Model):
	...
    users = db.relationship('User', back_populates='role')
    
class User(db.Model, UserMixin):
	...
    role_id = db.Column(db.Integer, db.ForeignKey('role.id'))
    role = db.relationship('Role', back_populates='users')
```

### 设置角色与权限

不同的程序会拥有不用的角色和权限。

![](blog/image/权限定义.png)

每个角色拥有不同的权限组合。 

![](blog/image/角色权限.png)

### 写入角色与权限

一般来说，程序的权限与角色一旦确定，就不会有大的变动 ，可以 直接在程序中预先定义。如果手动写入的话，太过麻烦，而且在开发环境中随时可能要重新生成数据库，可以在Role 模型类中创建一个方法负责这个工作 。

在此之前，需要把程序中角色和权限的对应关系保存下来。角色与权限的对应关系转化成下面的 roles_permissions_ map 字典：

```
roles_permissions_map = {
    'Locked': ['FOLLOW', 'COLLECT'],
    'User': ['FOLLOW', 'COLLECT', 'COMMENT', 'UPLOAD'],
    'Moderator': ['FOLLOW', 'COLLECT', 'COMMENT', 'UPLOAD', 'MODERATE'],
    'Administrator': ['FOLLOW', 'COLLECT', 'COMMENT', 'UPLOAD', 'MODERATE', 'ADMINISTER']
}
```
字典中的键表示角色的名称，对应的值则是每个角色对应的权限名称列表。

> 注：这里只有四种角色，没有访客和被封禁用户 。 访客不需要写入数据库，因为访客的作用就是用来表示不在数据库 中的用户 。而被封禁的用户不允许登录，虽然这类用户拥有账户， 但是其权限状态和访客完全相同 。

接下来我们将字典中的角色和权限以及对应的关系写入数据库。为了方便操作，我们将这部分代码定义为Role 类的静态方法初始化角色与权限：

```
class Role(db.Model):
	...
    @staticmethod
    def  init_role():
        roles_permissions_map = {
            'Locked': ['FOLLOW', 'COLLECT'],
            'User': ['FOLLOW', 'COLLECT', 'COMMENT', 'UPLOAD'],
            'Moderator': ['FOLLOW', 'COLLECT', 'COMMENT', 'UPLOAD', 'MODERATE'],
            'Administrator': ['FOLLOW', 'COLLECT', 'COMMENT', 'UPLOAD', 'MODERATE', 'ADMINISTER']
        }

        for role_name in roles_permissions_map:
            role = Role.query.filter_by(name=role_name).first()
            if role is None:
                role = Role(name=role_name)
                db.session.add(role)
            role.permissions = []
            for permission_name in roles_permissions_map[role_name]:
                permission = Permission.query.filter_by(name=permission_name).first()
                if permission is None:
                    permission = Permission(name=permission_name)
                    db.session.add(permission)
                role.permissions.append(permission)
        db.session.commit()

```

## 使用 Flask-Dropzone 优化文件上传

我们可以借助 JavaScript 库 实 现在客户端 实 时显示文件上传状态，而且这些 JavaScript 上传库还提供了文件的客户端验证功能 。常用的 JavaScript 文件上传库有 jQuery File Upload 、Dropzone .js 和 Plupload 等 。

Dropzone.js ( http://www.dropzonejs.com) 是一个开源的 JavaScript 上传插件，它几乎可以胜任我们上面设想的所有要求 。 除此之外，它还提供了拖拽上传功能，可以在客户端对文件的大小 、类型 进行过滤，而且有丰富的自定义选项，使用它可以让上传过程变得鲜活有趣，不至于让用户在这个过程中感到无聊 。

扩展 Flask-Dropzone 集成了 Dropzone.js，简化了大部分设置 ，并内置了对 CSRFPortect 扩展的支持 。

在 extensions 模块中 实例化扩展类 Dropzone:

```
from flask_dropzone import Dropzone
dropzone = Dropzone()
```

在工厂函数中调用 init_app()方法初始化扩展:

```
from blog.extensions import dropzone
def register_extensions(app):
	...
	dropzone.init_app(app)
```

### 配置 Flask-Dropzone

Flask-Dropzone 提供了一系列配置以对上传行为进行定制，常用 的 Flask-Dropzone 配置如下：

![](blog/image/Dropzone配置.png)

我们通过下面的配置来设置允许的文件最大值和单次上传最大数量：

```
DROPZONE MAX FILE SIZE= 3
DROPZONE MAX FILES= 30
```

设置在服务器端验证文件上传大小:

```
MAX CONTENT LENGTH= 3 * 1024 * 1024
```

Dropzone.js 通过文件的 MIME 类型以及后缀名判断文件类型 。 用来设置允许的文件类型的`DROPZONE_ALLOWED_FILE_TYPE` 配置变量接收 Flask -Dropzone 内置的类型值 。可用的内置文件类型变量值如下：

![](blog/image/Dropzone内置文件类型配置值.png)

如果想自定义允许的文件类型，要将配置键 `DROPZONE_ALLOWED_FILE_CUSTOM` 设为 True ,然后传入一个由文件 MIME 类型和后 缀名组成的字符串（使用分号隔开）:
```
DROPZONE ALLOWED FILE CUSTOM= True
DROPZONE_ALLOWED_FILE_TYPE = ' image/*, .pdf , .txt '
```

##### 添加md文档

> 在这里增加.md就可以上传md文件。

当上传失败时，图片缩略图下面会显示 一个错误提示弹窗。错误提示的语言默认为英文，可以使用 Flask-Dropzone 提供的配置变量来自定义提示消息 。

![](blog/image/Dropzone错误消息配置变量.png)

另外，Flask-Dropzone 还内置了对 CSRf Protect 扩展的支持：

将 Flask-Dropzone 提供的 DROPZONE_ENABLE_CSRF 配置变量设为 True 即可开启 CSRF保护 。Flask-Dropzone 会在上传区域对应的表单中添加 CSRF 令牌隐藏字段，在处理文件上传请求时，CSRf Protect 会自动验证 CSRF 令牌：

```
DROPZONE ENABLE CSRF = True
```

### 渲染上传区域

用于上传图片的 upload.html 模板：

```
{% extends 'base.html' %}

{% block title %}Upload{% endblock %}

{% block styles %}
    {{ super() }}
    <link rel="stylesheet" href="{{ url_for('static', filename='css/dropzone.min.css') }}" type="text/css">
    {{ dropzone.style('margin: 20px 0; border: 2px dashed #0087F7; min-height: 400px;') }}
{% endblock %}

{% block content %}
    <div class="page-header">
        <h1>Upload</h1>
    </div>
    <div class="row">
        <div class="col-md-12">
            {{ dropzone.create(action='main.upload') }}
            <a class="btn btn-light float-right" href="{{ url_for('user.index', username=current_user.username) }}">
                Done
            </a>
        </div>
    </div>
{% endblock %}

{% block scripts %}
    {{ super() }}
    <script src="{{ url_for('static', filename='js/dropzone.min.js') }}"></script>
    {{ dropzone.config() }}
{% endblock %}

```

### 处理并保存上传文件

#### 1．保存图片
为了保存每个图片的信息，除了将图片文件保存到文件系统外，我们还需要在数据库中为图片创建记录。

```
class Photo(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    description = db.Column(db.String(500))
    filename = db.Column(db.String(64))
    timestamp = db.Column(db.DateTime, default=datetime.utcnow, index=True)
    ...
```

description 字段存储图片的对应的博文，filename 字段存储文件名，timestamp 字段则存储图片上传时间 。

Photo 模型 和 User 模型的一对多关系如下所示：

```
class User(db.Model, UserMixin):
	...
    role_id = db.Column(db.Integer, db.ForeignKey('role.id'))
    role = db.relationship('Role', back_populates='users')
class Photo(db.Model):
	...
    author_id = db.Column(db.Integer, db.ForeignKey('user.id'))
    author = db.relationship('User', back_populates='photos')
```

我们在 Photo 模型中创建一个外键字段 author_id 存储 User 记 录的 id 值 。 在 User 类中的集合关系属性 photos 中，我们把级联设为 all , 这样当某个用户被删除时，对应的图片记录也可以被一并删除 。

在开发时，为了便于测试，把图片文件保存到项目根目录下创建的 uploads 文件夹下，这个上传路径保存到配置变量 `BLOG_UPLOAD_PATH` 中，以便在程序中获取 ：

blog/settings

```
basedir = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
...
BLOG_UPLOAD_PATH = os.path.join(basedir, 'uploads')
```

在视图函数中验证和保存 Dropzone.js提交的文件:

blueprints/main.py

```
@main_bp.route('/upload', methods=['GET', 'POST'])
@login_required #验证登录状态
@confirm_required # 验证确认状态
@permission_required('UPLOAD') # 验证权限
def upload():
    if request.method == 'POST' and 'file' in request.files:
        f = request.files.get('file') # 获取图片文件对象
        filename = rename_image(f.filename) # 生成随机文件名
        f.save(os.path.join(current_app.config['BLOG_UPLOAD_PATH'], filename)) # 保存文件
        photo = Photo( # 创建文件记录
            filename=filename,
            author=current_user._get_current_object()
        )
        db.session.add(photo)
        db.session.commit()
    return render_template('main/upload.html')
```

除了login_required 装饰器外，还为upload 视图附加了 confirm_required 装饰器和permission_required('UPLOAD')，前者用来过滤未确认邮箱地址的用 户，后者用来过滤没有 UPLOAD 权限的用 户。

为了避免用户绕过客户端验证，我们仍然需要在服务器端对上传的文件进行验证 。Flask ­- Dropzone 创建的上传字段 name 属性值默认为file ,使用这个值作为键获取文件，重命名文件名后保存到指定路径。图片保存后，创建相应的 Photo 类实例作为图片记录，将图片的文件名保存到 filename 字段中，最后提交数据库会话 。

#### 2．图片裁剪

网页中包含大量图片会延长页面的加载速度，为了优化页面加载速度 ，最基本的做法是在不同的场景下使用不同尺寸的图片 。

比如，在用户主页显示图片的小型尺寸；在图片展示页面，使用中型尺寸；在查看原图页面使用原始尺寸。 在用户上传图片时，我们需要对上传的图片进行缩小 。

在 Photo 模型中，除了保存文件名的 filename 字段，还创建了两个类似的 字段：file­name_s 和 filename_m,它们分别用于存储小型尺寸(small) 的图片 文件名 和中型尺寸(medium)的图片文件名：

```
class Photo(db.Model):
	...
    filename = db.Column(db.String(64))
    filename_s = db.Column(db.String(64))
    filename_m = db.Column(db.String(64))
```

我们需要在文件上传后对图片进行缩放处理，然后保存这两种尺寸的文件名到上述两个字段里。为了方便对文件名做区分，我们需要为图片文件名添加后缀，尺寸和后缀名的匹配关系通过两个配置变量来表示：

```
BLOG_PHOTO_SIZE = {'small': 400,
                     'medium': 800}
BLOG_PHOTO_SUFFIX = {
    BLOG_PHOTO_SIZE['small']: '_s',  # thumbnail
    BLOG_PHOTO_SIZE['medium']: '_m',  # display
}
```

用于生成不同尺寸的图片 resize_image(）函数 :

blog/utils.py

```
def resize_image(image, filename, base_width):
    filename, ext = os.path.splitext(filename)
    img = Image.open(image)
    if img.size[0] <= base_width:
        return filename + ext
    w_percent = (base_width / float(img.size[0]))
    h_size = int((float(img.size[1]) * float(w_percent)))
    img = img.resize((base_width, h_size), PIL.Image.ANTIALIAS)

    filename += current_app.config['BLOG_PHOTO_SUFFIX'][base_width] + ext
    img.save(os.path.join(current_app.config['BLOG_UPLOAD_PATH'], filename), optimize=True, quality=85)
    return filename

```

在 resize_image(）函数中，首先判断图片的宽度是否小于要设置的宽度， 如果小于，那么就不需要裁剪，直接返回原文件的文件名。接着根据图片的设置宽度对图片进行缩小处理，最后调用图片对象的 save()方法将图片保存在上传文件夹并返回文件名，文件名中的后缀通过将传入的宽度值作为键从 `BLOG_PHOTO_SUFFIX` 获取 。

在 upload 视图中，在保存文件后调用 resize_image()函数生成中型和小型尺寸的图片，并保存到对应的模型类字段中：

```
@main_bp.route('/upload', methods=['GET', 'POST'])
@login_required
@confirm_required
@permission_required('UPLOAD')
def upload():
	...
        f.save(os.path.join(current_app.config['BLOG_UPLOAD_PATH'], filename))
        filename_s = resize_image(f, filename, current_app.config['BLOG_PHOTO_SIZE']['small'])
        filename_m = resize_image(f, filename, current_app.config['BLOG_PHOTO_SIZE']['medium'])
        photo = Photo(
            filename=filename,
            filename_s=filename_s,
            filename_m=filename_m,
            author=current_user._get_current_object()
        )
        db.session.add(photo)
        db.session.commit()
    return render_template('main/upload.html')
```

在实际的应用中，中型尺寸的图片展示在详情页，而在用户主页等展示图 片列表的地方则使用小型尺寸 。 在用户想要查看原图时，则使用原始尺寸 。

## 使用 Flask-Avatars 处理用户头像

几乎在所有的社交网站里，用户都会拥有自己的头像。头像会和用户的名字放在一起，作为用户的另一个重要标识 。Flask-Avatars 提供了用户头像的多种实现方式 ：默认头像、在线头像(Gravatar 等）、社交网站头像(Facebook 、Twitter 或是 Instagram) 、生成随机头像以及用户上传自 定义头像等 。

在 extensions 模块中 实例化扩展类 Avatars :

```
from flask_avatars import Avatars 
dropzone = Avatars()
```

在工厂函数中调用 init_app()方法初始化扩展:

```
from blog.extensions import avatars
def register_extensions(app):
	...
	avatars.init_app(app)
```

### 默认头像
当用户注册以后，此时还没有设置自定义头像，需要给用户设置一个默认 头像 。 除了自己添加图片文件到 static 目录，然后在模板中引用外，也可以使用 Flask-Avatars 提供的默认头像 。

Flask- Avatars 在模板中开放了 avatars 类 ，对这个类调用 default() 方法可以获取它内置的默认头像（一个灰色背景的人形轮廓图片）的 URL :
```
<img src={{ "avatars.default()" }}>
```

可选的 size 参数表示图片的大小，图片的宽度和高度相同。Flask - Avatars 提供了 三种尺寸选项 ：s、m 、l ,分别表示 small(48px) 、medium (l28px) 、large (256px) ，默认为 m 。如果需要其他尺寸，可以使用最接近的尺寸选项，然后在 `<img>` 标签中设置 width 和 height 属性或设置 CSS 样式类 。

### 生成随机头像

在生成头像之前，需要进行一些基础配置 。 配置键 `AVATARS_SAVE_PATH` 用来设置头像文件的保存路径,配置键 `AVATARS_SIZE_TUPLE` 用来设置三种尺寸的头像图片大小 ，这个值必须由一个包含三个元素的元组组成，元组中的数字分别表示小 、中 、大三个尺寸，默认值为"(30, 60, 150)” 。

```
AVATARS_SAVE_PATH = os.path.join(BLOG_UPLOAD_PATH, 'avatars')
AVATARS_SIZE_TUPLE = (30, 100, 200)
```

生成头像的最佳时间是在用户注册时，我 们 创建一个用于生成随机头像文件的 generate_avatar(）方法，在 User 类的构造方法中调用 。三 种尺寸头像的文件名 则 分别保存到新创建的avatar_s 、avatar_m 、avatar_ l 字段里:

生成头像文件：

models.py

```
class User(db.Model, UserMixin):
	...
    avatar_s = db.Column(db.String(64))
    avatar_m = db.Column(db.String(64))
    avatar_l = db.Column(db.String(64))
    avatar_raw = db.Column(db.String(64))
    
    def __init__(self, **kwargs):
        super(User, self).__init__(**kwargs)
        ...
        self.generate_avatar()
        
    def generate_avatar(self):
        avatar = Identicon()
        filenames = avatar.generate(text=self.username)
        self.avatar_s = filenames[0]
        self.avatar_m = filenames[1]
        self.avatar_l = filenames[2]
        db.session.commit()
```



### GAN对抗生成图像

参考书籍：

![](blog/image/GAN生成对抗网络-参考书.png)

第5章 图像生成

本章介绍了图像生成GAN的各类模型与应用，包括全卷积GAN，条件GAN，多尺度GAN，属性GAN，多判别器与生成器GAN，数据增强与仿真GAN，并进行了DCGAN与StyleGAN图像生成任务的实践。

#### 原始数据集的搜集

爬了动漫图库网站：[konachan.net - Konachan.com Anime Wallpapers](http://konachan.net/post?page=3&tags=)。

爬取目标：img

两种爬取方式：

1。从img标签过滤class=“preview”获取src保存

2。从a标签过滤class_=“directlink largeimg“获取href保存

![](blog/image/GAN-搜集数据.png)

爬虫代码如下：

pachong.py

```
#采用request+beautiful库爬取
import random

import requests
from bs4 import BeautifulSoup
import os
import traceback

headers_list = [
    {
        'user-agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 8.0.0; SM-G955U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 10; SM-G981B) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.162 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (iPad; CPU OS 13_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/87.0.4280.77 Mobile/15E148 Safari/604.1'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.109 Safari/537.36 CrKey/1.54.248666'
    }, {
        'user-agent': 'Mozilla/5.0 (X11; Linux aarch64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.188 Safari/537.36 CrKey/1.54.250320'
    }, {
        'user-agent': 'Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+'
    }, {
        'user-agent': 'Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.84 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.111 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.80 Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 6.0.1; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)'
    }, {
        'user-agent': 'Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.158 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/81.0.4044.138 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 11; Pixel 3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.181 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Mobile Safari/537.36'
    }, {
        'user-agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1'
    }, {
        'user-agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1'
    }, {
        'user-agent': 'Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1'
    }
]

headers = random.choice(headers_list)





def download(url, filename):#判断文件是否存在，存在则退出本次循环
    if os.path.exists(filename):
        print('file exists!')
        return
    try:
        r = requests.get(url, stream=True, timeout=60, headers=headers)#以流数据形式请求，你可获取来自服务器的原始套接字响应
        r.raise_for_status()
        with open(filename, 'wb') as f:#将文本流保存到文件
            for chunk in r.iter_content(chunk_size=1024):
                if chunk:  # filter out keep-alive new chunks
                    f.write(chunk)
                    f.flush()
        return filename
    except KeyboardInterrupt:
        if os.path.exists(filename):
            os.remove(filename)
        raise KeyboardInterrupt
    except Exception:
        traceback.print_exc()#把返回信息输出到控制台
        if os.path.exists(filename):
            os.remove(filename)


if os.path.exists('../imgs') is False:
    os.makedirs('../imgs')

start = 1
end = 3
for i in range(start, end + 1):
    url = 'http://konachan.net/post?page=%d&tags=' % i#需要爬取的url
    html = requests.get(url,headers=headers).text#获取的html页面内容
    soup = BeautifulSoup(html, 'html.parser')
    for img in soup.find_all('img', class_="preview"):
        target_url = img['src']
        filename = os.path.join('../imgs', target_url.split('/')[-1])
        download(target_url, filename)
    print('%d / %d' % (i, end))

```



说明：目前网站增加了反爬措施，修改请求头、用代理IP、延时爬取这些简单的反反爬机制都不起作用，之后会考虑用selenium库模拟浏览器获取。（估计是封掉了IP）

#### 数据处理

由于这些图片比较复杂，对于网络难以训练，我们需要截取出动漫人物的头像，通过[opencv](https://so.csdn.net/so/search?q=opencv&spm=1001.2101.3001.7020)工具，github上面已经有这个项目应用，[A Face detector for anime/manga using OpenCV (github.com)](https://github.com/nagadomi/lbpcascade_animeface)

touxiang.py

```
import cv2
import sys
import os.path
from glob import glob

def detect(filename, cascade_file="lbpcascade_animeface.xml"):
    if not os.path.isfile(cascade_file):
        raise RuntimeError("%s: not found" % cascade_file)

    cascade = cv2.CascadeClassifier(cascade_file)
    image = cv2.imread(filename)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.equalizeHist(gray)

    faces = cascade.detectMultiScale(gray,
                                     # detector options
                                     scaleFactor=1.1,
                                     minNeighbors=5,
                                     minSize=(48, 48))
    for i, (x, y, w, h) in enumerate(faces):
        face = image[y: y + h, x:x + w, :]
        face = cv2.resize(face, (96, 96))
        save_filename = '%s-%d.jpg' % (os.path.basename(filename).split('.')[0], i)
        cv2.imwrite("faces/" + save_filename, face)


if __name__ == '__main__':
    if os.path.exists('faces') is False:
        os.makedirs('faces')
    file_list = glob('imgs/*.jpg')
    for filename in file_list:
        detect(filename)
```

以下是截取出来的图：

![](blog/image/GAN-截取人物头像.png)

#### 训练图像

引用DCGAN的github代码，[“深度卷积生成对抗网络”的 tensorflow 实现 (github.com)](https://github.com/carpedm20/DCGAN-tensorflow)
